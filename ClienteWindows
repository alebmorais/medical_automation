#!/usr/bin/env python3
# Cliente Desktop para Windows - Automa√ß√£o M√©dica
# Interface nativa com fundo azul escuro, navega√ß√£o por voz, atalhos e cliques
# Detecta automaticamente se est√° no Windows e s√≥ ativa neste sistema

import json
import os
import platform
import sys
import threading
import time
import tkinter as tk
from tkinter import messagebox, ttk
from urllib import request as urllib_request
import traceback

# Fun√ß√£o utilit√°ria para lidar com pausas sem depender de input() em ambientes
# onde stdin pode n√£o estar dispon√≠vel (ex: execu√ß√£o por atalho ou como
# aplicativo empacotado).
def pause_for_user(prompt, delay_seconds=3):
    """Exibe uma mensagem de pausa sem exigir entrada quando stdin n√£o existe."""
    try:
        if sys.stdin and sys.stdin.isatty():
            input(prompt)
            return
    except (EOFError, RuntimeError):
        pass

    # Ambiente n√£o interativo: apenas informar e aguardar brevemente para que
    # o usu√°rio leia a mensagem.
    message = prompt.strip() or "Pressione Enter para continuar..."
    print(message)
    time.sleep(max(delay_seconds, 0))

# Tentar importar bibliotecas opcionais

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    requests = None



try:
    import pyautogui
    AUTOGUI_AVAILABLE = True
except ImportError:
    AUTOGUI_AVAILABLE = False

try:
    import pynput
    from pynput import keyboard
    PYNPUT_AVAILABLE = True
except ImportError:
    PYNPUT_AVAILABLE = False

try:
    import webview

    WEBVIEW_AVAILABLE = True
except ImportError:
    WEBVIEW_AVAILABLE = False
    webview = None


class WindowsDesktopClient:
    def __init__(self):
        """Inicializar o cliente desktop e configurar depend√™ncias."""
        # Verificar se est√° no Windows
        if platform.system() != "Windows":
            print("Sistema n√£o √© Windows. Cliente desktop n√£o ser√° iniciado.")
            return

        # Configura√ß√µes
        self.pi_url = "http://pi.local:8080"
        
        self.current_phrase = None

        # Dados
        self.categories = []
        self.subcategories = []
        self.phrases = []
        self.selected_category = None
        self.selected_subcategory = None

        # Interface
        self.root = None
        
        
        self.webview_window = None
        self.ui_mode = None
        self.pending_webview = False
        self.force_legacy_ui = False
        self.legacy_initialized = False

        # Inicializar
        
        self.setup_gui()
        if self.ui_mode == "legacy":
            self.initialize_legacy_mode()

    def initialize_legacy_mode(self):
        """Ensure that legacy mode helpers are configured only once."""
        if self.legacy_initialized:
            return
        self.setup_keyboard_shortcuts()
        self.load_categories()
        self.legacy_initialized = True

    def setup_keyboard_shortcuts(self):
        """Configurar atalhos de teclado globais usando HotKey para combina√ß√µes."""
        if not PYNPUT_AVAILABLE:
            self.update_status(
                "Atalhos de teclado desativados. Instale 'pynput' para habilit√°-los."
            )
            return

        def on_type_activate():
            print("Atalho Ctrl+Alt+D ativado: Digitar frase.")
            self.auto_type_phrase()

        def on_copy_activate():
            print("Atalho Ctrl+C ativado: Copiar frase.")
            self.copy_phrase()

        def on_minimize_activate():
            print("Atalho Ctrl+Alt+M ativado: Minimizar/Restaurar.")
            self.toggle_minimize()

        # Definir os atalhos
        hotkeys = {
            '<ctrl>+<alt>+d': on_type_activate,
            '<ctrl>+c': on_copy_activate,
            '<ctrl>+<alt>m': on_minimize_activate,
        }

        # Iniciar o listener em uma thread separada
        listener = keyboard.GlobalHotKeys(hotkeys)
        listener.start()

        self.update_status(
            "Pronto. Atalhos: Ctrl+Alt+D (digitar), Ctrl+C (copiar), Ctrl+Alt+M (minimizar)."
        )

    def setup_gui(self):
        """Criar interface do cliente."""
        # Paleta comum para fallback/legado
        self.colors = {
            "bg_primary": "#1a237e",  # Azul escuro principal
            "bg_secondary": "#283593",  # Azul m√©dio
            "bg_accent": "#3f51b5",  # Azul claro
            "text_primary": "#ffffff",  # Branco
            "text_secondary": "#e8eaf6",  # Branco levemente azulado
            "button_active": "#4caf50",  # Verde
            "button_hover": "#66bb6a",  # Verde claro
            "border": "#5c6bc0",  # Azul para bordas
        }

        pi_reachable = self.is_pi_reachable()

        if WEBVIEW_AVAILABLE and pi_reachable and not self.force_legacy_ui:
            self.ui_mode = "webview"
            self.webview_window = webview.create_window(
                "Automa√ß√£o M√©dica",
                self.pi_url,
                width=1000,
                height=700,
                resizable=True,
            )
            return

        # Necess√°rio criar janela Tk para fallback ou interface legada
        self.root = tk.Tk()
        self.root.title("Automa√ß√£o M√©dica")
        self.root.geometry("1000x700")
        self.root.configure(bg=self.colors["bg_primary"])
        self.root.attributes("-topmost", True)

        if not pi_reachable:
            self.ui_mode = "fallback"
            self.build_offline_screen()
            return

        # Quando pywebview n√£o est√° dispon√≠vel, mantemos a UI Tk existente
        if not WEBVIEW_AVAILABLE:
            print(
                "pywebview n√£o foi encontrado. Utilizando interface Tkinter tradicional."
            )

        self.ui_mode = "legacy"

        # Configurar estilo ttk apenas no modo legado
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Dark.TFrame", background=self.colors["bg_primary"])
        style.configure(
            "Dark.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10),
        )
        style.configure(
            "Title.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 16, "bold"),
        )
        style.configure(
            "Dark.TButton",
            background=self.colors["bg_accent"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10, "bold"),
        )

        self.create_header()
        
        self.create_navigation_area()
        self.create_preview_area()
        self.create_status_bar()

        self.root.focus_set()
        self.root.bind("<Escape>", lambda e: self.toggle_minimize())
        self.root.bind("<F11>", lambda e: self.toggle_fullscreen())

    def build_offline_screen(self):
        """Exibir tela simples informando aus√™ncia de conex√£o."""
        container = tk.Frame(self.root, bg=self.colors["bg_primary"])
        container.pack(expand=True, fill=tk.BOTH, padx=40, pady=40)

        title = tk.Label(
            container,
            text="N√£o foi poss√≠vel acessar o Raspberry Pi.",
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 18, "bold"),
            wraplength=600,
            justify="center",
        )
        title.pack(pady=(0, 20))

        instructions = (
            "Verifique se o Raspberry Pi est√° ligado e conectado √† rede. "
            "Conecte o computador ao mesmo Wi-Fi ou cabo e tente novamente."
        )
        self.fallback_status_var = tk.StringVar(value=instructions)
        status_label = tk.Label(
            container,
            textvariable=self.fallback_status_var,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 11),
            wraplength=600,
            justify="center",
        )
        status_label.pack(pady=(0, 20))

        button_frame = tk.Frame(container, bg=self.colors["bg_primary"])
        button_frame.pack()

        retry_button = tk.Button(
            button_frame,
            text="Tentar novamente",
            command=self.retry_connection,
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        retry_button.pack(side=tk.LEFT, padx=10)

        close_button = tk.Button(
            button_frame,
            text="Fechar",
            command=self.root.destroy,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        close_button.pack(side=tk.LEFT, padx=10)

        if not WEBVIEW_AVAILABLE:
            note = tk.Label(
                container,
                text=(
                    "Observa√ß√£o: instale o pacote 'pywebview' para carregar a interface "
                    "web moderna diretamente no aplicativo."
                ),
                bg=self.colors["bg_primary"],
                fg=self.colors["text_secondary"],
                font=("Segoe UI", 10),
                wraplength=600,
                justify="center",
            )
            note.pack(pady=(20, 0))

    def retry_connection(self):
        """Tentar reconectar ao Pi e abrir a webview se poss√≠vel."""
        if not self.is_pi_reachable():
            self.fallback_status_var.set(
                "Ainda n√£o foi poss√≠vel conectar. Confira os cabos/rede e tente novamente."
            )
            return

        if WEBVIEW_AVAILABLE:
            self.fallback_status_var.set(
                "Conex√£o restabelecida! Abrindo a interface web..."
            )
            self.root.after(200, self._open_webview_after_fallback)
        else:
            self.fallback_status_var.set(
                "Conectado ao Pi! Instale o pacote 'pywebview' e reabra o aplicativo "
                "para usar a interface moderna."
            )

    def _open_webview_after_fallback(self):
        """Encerrar a janela Tk e preparar a webview."""
        if not WEBVIEW_AVAILABLE:
            return
        self.pending_webview = True
        self.force_legacy_ui = False
        if self.root:
            self.root.destroy()
            self.root = None
        self.webview_window = webview.create_window(
            "Automa√ß√£o M√©dica",
            self.pi_url,
            width=1000,
            height=700,
            resizable=True,
        )

    def is_pi_reachable(self, timeout=3):
        """Verificar se a URL do Pi responde."""
        try:
            if REQUESTS_AVAILABLE:
                response = requests.get(self.pi_url, timeout=timeout)
                return response.status_code < 500
            with urllib_request.urlopen(self.pi_url, timeout=timeout) as response:
                return 200 <= getattr(response, "status", 200) < 500
            return False
        except Exception as e:
            print(f"Falha ao verificar a disponibilidade do Pi: {e}")
            traceback.print_exc()
            return False

    def create_header(self):
        """Criar cabe√ßalho"""
        header_frame = tk.Frame(self.root, bg=self.colors["bg_secondary"], height=80)
        header_frame.pack(fill=tk.X, padx=2, pady=2)
        header_frame.pack_propagate(False)

        # T√≠tulo
        title_label = tk.Label(
            header_frame,
            text="üè• Automa√ß√£o M√©dica",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 20, "bold"),
        )
        title_label.pack(expand=True)

        # Subt√≠tulo
        subtitle_label = tk.Label(
            header_frame,
            text="Neurologia",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 12),
        )
        subtitle_label.pack()

    

    def create_navigation_area(self):
        """Criar √°rea de navega√ß√£o com 3 colunas"""
        nav_frame = tk.Frame(self.root, bg=self.colors["bg_primary"])
        nav_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Configurar grid
        nav_frame.grid_columnconfigure(0, weight=1)
        nav_frame.grid_columnconfigure(1, weight=1)
        nav_frame.grid_columnconfigure(2, weight=1)
        nav_frame.grid_rowconfigure(0, weight=1)

        # Coluna 1: Categorias
        self.create_list_column(nav_frame, "üìã Categorias", 0, "categories")

        # Coluna 2: Subcategorias
        self.create_list_column(nav_frame, "üìë Subcategorias", 1, "subcategories")

        # Coluna 3: Frases
        self.create_list_column(nav_frame, "üí¨ Frases", 2, "phrases")

    def create_list_column(self, parent, title, column, list_type):
        """Criar uma coluna de lista"""
        # Frame da coluna
        col_frame = tk.Frame(
            parent, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        col_frame.grid(row=0, column=column, sticky="nsew", padx=2, pady=2)

        # T√≠tulo
        title_label = tk.Label(
            col_frame,
            text=title,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=10,
        )
        title_label.pack(fill=tk.X)

        # Listbox
        listbox_frame = tk.Frame(col_frame, bg=self.colors["bg_secondary"])
        listbox_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        listbox = tk.Listbox(
            listbox_frame,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            selectbackground=self.colors["bg_accent"],
            selectforeground=self.colors["text_primary"],
            font=("Segoe UI", 10),
            relief="flat",
            bd=0,
        )

        scrollbar = tk.Scrollbar(listbox_frame, orient="vertical")
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.configure(command=listbox.yview)

        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Configurar eventos
        if list_type == "categories":
            self.categories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_category_select)
        elif list_type == "subcategories":
            self.subcategories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_subcategory_select)
        elif list_type == "phrases":
            self.phrases_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_phrase_select)

    def create_preview_area(self):
        """Criar √°rea de preview da frase"""
        preview_frame = tk.Frame(
            self.root, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        preview_frame.pack(fill=tk.X, padx=10, pady=5)

        # T√≠tulo
        preview_title = tk.Label(
            preview_frame,
            text="üëÅÔ∏è Preview da Frase Selecionada",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=5,
        )
        preview_title.pack()

        # √Årea de texto
        text_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        text_frame.pack(fill=tk.X, padx=10, pady=5)

        self.preview_text = tk.Text(
            text_frame,
            height=6,
            wrap=tk.WORD,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Consolas", 10),
            relief="flat",
            bd=0,
            state="disabled",
        )

        preview_scrollbar = tk.Scrollbar(text_frame, orient="vertical")
        self.preview_text.configure(yscrollcommand=preview_scrollbar.set)
        preview_scrollbar.configure(command=self.preview_text.yview)

        self.preview_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        preview_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Bot√µes de a√ß√£o
        buttons_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        buttons_frame.pack(pady=10)

        # Bot√£o de digitar
        self.type_button = tk.Button(
            buttons_frame,
            text="‚å®Ô∏è Digitar Automaticamente (F5)",
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.auto_type_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.type_button.pack(side=tk.LEFT, padx=5)

        # Bot√£o de copiar
        self.copy_button = tk.Button(
            buttons_frame,
            text="üìã Copiar para Clipboard",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.copy_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.copy_button.pack(side=tk.LEFT, padx=5)

    def create_status_bar(self):
        """Criar barra de status"""
        self.status_bar = tk.Label(
            self.root,
            text="Pronto - Conecte-se ao Pi Zero",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 9),
            relief="sunken",
            bd=1,
            anchor="w",
            padx=10,
        )
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def setup_keyboard_shortcuts(self):
        """Configurar atalhos de teclado globais usando HotKey para combina√ß√µes."""
        if not PYNPUT_AVAILABLE:
            self.update_status(
                "Atalhos de teclado desativados. Instale 'pynput' para habilit√°-los."
            )
            return

        def on_type_activate():
            print("Atalho Ctrl+Alt+D ativado: Digitar frase.")
            self.auto_type_phrase()

        def on_copy_activate():
            print("Atalho Ctrl+Alt+C ativado: Copiar frase.")
            self.copy_phrase()

        def on_minimize_activate():
            print("Atalho Ctrl+Alt+M ativado: Minimizar/Restaurar.")
            self.toggle_minimize()

        # Definir os atalhos
        hotkeys = {
            '<ctrl>+<alt>+d': on_type_activate,
            '<ctrl>+<alt>+c': on_copy_activate,
            '<ctrl>+<alt>m': on_minimize_activate,
        }

        # Iniciar o listener em uma thread separada
        listener = keyboard.GlobalHotKeys(hotkeys)
        listener.start()

        self.update_status(
            "Pronto. Atalhos: Ctrl+Alt+D (digitar), Ctrl+Alt+C (copiar), Ctrl+Alt+M (minimizar)."
        )

    def setup_gui(self):
        """Criar interface do cliente."""
        # Paleta comum para fallback/legado
        self.colors = {
            "bg_primary": "#1a237e",  # Azul escuro principal
            "bg_secondary": "#283593",  # Azul m√©dio
            "bg_accent": "#3f51b5",  # Azul claro
            "text_primary": "#ffffff",  # Branco
            "text_secondary": "#e8eaf6",  # Branco levemente azulado
            "button_active": "#4caf50",  # Verde
            "button_hover": "#66bb6a",  # Verde claro
            "border": "#5c6bc0",  # Azul para bordas
        }

        pi_reachable = self.is_pi_reachable()

        if WEBVIEW_AVAILABLE and pi_reachable and not self.force_legacy_ui:
            self.ui_mode = "webview"
            self.webview_window = webview.create_window(
                "Automa√ß√£o M√©dica",
                self.pi_url,
                width=1000,
                height=700,
                resizable=True,
            )
            return

        # Necess√°rio criar janela Tk para fallback ou interface legada
        self.root = tk.Tk()
        self.root.title("Automa√ß√£o M√©dica")
        self.root.geometry("1000x700")
        self.root.configure(bg=self.colors["bg_primary"])
        self.root.attributes("-topmost", True)

        if not pi_reachable:
            self.ui_mode = "fallback"
            self.build_offline_screen()
            return

        # Quando pywebview n√£o est√° dispon√≠vel, mantemos a UI Tk existente
        if not WEBVIEW_AVAILABLE:
            print(
                "pywebview n√£o foi encontrado. Utilizando interface Tkinter tradicional."
            )

        self.ui_mode = "legacy"

        # Configurar estilo ttk apenas no modo legado
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Dark.TFrame", background=self.colors["bg_primary"])
        style.configure(
            "Dark.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10),
        )
        style.configure(
            "Title.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 16, "bold"),
        )
        style.configure(
            "Dark.TButton",
            background=self.colors["bg_accent"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10, "bold"),
        )

        self.create_header()
        
        self.create_navigation_area()
        self.create_preview_area()
        self.create_status_bar()

        self.root.focus_set()
        self.root.bind("<Escape>", lambda e: self.toggle_minimize())
        self.root.bind("<F11>", lambda e: self.toggle_fullscreen())

    def build_offline_screen(self):
        """Exibir tela simples informando aus√™ncia de conex√£o."""
        container = tk.Frame(self.root, bg=self.colors["bg_primary"])
        container.pack(expand=True, fill=tk.BOTH, padx=40, pady=40)

        title = tk.Label(
            container,
            text="N√£o foi poss√≠vel acessar o Raspberry Pi.",
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 18, "bold"),
            wraplength=600,
            justify="center",
        )
        title.pack(pady=(0, 20))

        instructions = (
            "Verifique se o Raspberry Pi est√° ligado e conectado √† rede. "
            "Conecte o computador ao mesmo Wi-Fi ou cabo e tente novamente."
        )
        self.fallback_status_var = tk.StringVar(value=instructions)
        status_label = tk.Label(
            container,
            textvariable=self.fallback_status_var,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 11),
            wraplength=600,
            justify="center",
        )
        status_label.pack(pady=(0, 20))

        button_frame = tk.Frame(container, bg=self.colors["bg_primary"])
        button_frame.pack()

        retry_button = tk.Button(
            button_frame,
            text="Tentar novamente",
            command=self.retry_connection,
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        retry_button.pack(side=tk.LEFT, padx=10)

        close_button = tk.Button(
            button_frame,
            text="Fechar",
            command=self.root.destroy,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        close_button.pack(side=tk.LEFT, padx=10)

        if not WEBVIEW_AVAILABLE:
            note = tk.Label(
                container,
                text=(
                    "Observa√ß√£o: instale o pacote 'pywebview' para carregar a interface "
                    "web moderna diretamente no aplicativo."
                ),
                bg=self.colors["bg_primary"],
                fg=self.colors["text_secondary"],
                font=("Segoe UI", 10),
                wraplength=600,
                justify="center",
            )
            note.pack(pady=(20, 0))

    def retry_connection(self):
        """Tentar reconectar ao Pi e abrir a webview se poss√≠vel."""
        if not self.is_pi_reachable():
            self.fallback_status_var.set(
                "Ainda n√£o foi poss√≠vel conectar. Confira os cabos/rede e tente novamente."
            )
            return

        if WEBVIEW_AVAILABLE:
            self.fallback_status_var.set(
                "Conex√£o restabelecida! Abrindo a interface web..."
            )
            self.root.after(200, self._open_webview_after_fallback)
        else:
            self.fallback_status_var.set(
                "Conectado ao Pi! Instale o pacote 'pywebview' e reabra o aplicativo "
                "para usar a interface moderna."
            )

    def _open_webview_after_fallback(self):
        """Encerrar a janela Tk e preparar a webview."""
        if not WEBVIEW_AVAILABLE:
            return
        self.pending_webview = True
        self.force_legacy_ui = False
        if self.root:
            self.root.destroy()
            self.root = None
        self.webview_window = webview.create_window(
            "Automa√ß√£o M√©dica",
            self.pi_url,
            width=1000,
            height=700,
            resizable=True,
        )

    def is_pi_reachable(self, timeout=3):
        """Verificar se a URL do Pi responde."""
        try:
            if REQUESTS_AVAILABLE:
                response = requests.get(self.pi_url, timeout=timeout)
                return response.status_code < 500
            with urllib_request.urlopen(self.pi_url, timeout=timeout) as response:
                return 200 <= getattr(response, "status", 200) < 500
            return False
        except Exception as e:
            print(f"Falha ao verificar a disponibilidade do Pi: {e}")
            traceback.print_exc()
            return False

    def create_header(self):
        """Criar cabe√ßalho"""
        header_frame = tk.Frame(self.root, bg=self.colors["bg_secondary"], height=80)
        header_frame.pack(fill=tk.X, padx=2, pady=2)
        header_frame.pack_propagate(False)

        # T√≠tulo
        title_label = tk.Label(
            header_frame,
            text="üè• Automa√ß√£o M√©dica",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 20, "bold"),
        )
        title_label.pack(expand=True)

        # Subt√≠tulo
        subtitle_label = tk.Label(
            header_frame,
            text="Neurologia",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 12),
        )
        subtitle_label.pack()

    

    def create_navigation_area(self):
        """Criar √°rea de navega√ß√£o com 3 colunas"""
        nav_frame = tk.Frame(self.root, bg=self.colors["bg_primary"])
        nav_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Configurar grid
        nav_frame.grid_columnconfigure(0, weight=1)
        nav_frame.grid_columnconfigure(1, weight=1)
        nav_frame.grid_columnconfigure(2, weight=1)
        nav_frame.grid_rowconfigure(0, weight=1)

        # Coluna 1: Categorias
        self.create_list_column(nav_frame, "üìã Categorias", 0, "categories")

        # Coluna 2: Subcategorias
        self.create_list_column(nav_frame, "üìë Subcategorias", 1, "subcategories")

        # Coluna 3: Frases
        self.create_list_column(nav_frame, "üí¨ Frases", 2, "phrases")

    def create_list_column(self, parent, title, column, list_type):
        """Criar uma coluna de lista"""
        # Frame da coluna
        col_frame = tk.Frame(
            parent, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        col_frame.grid(row=0, column=column, sticky="nsew", padx=2, pady=2)

        # T√≠tulo
        title_label = tk.Label(
            col_frame,
            text=title,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=10,
        )
        title_label.pack(fill=tk.X)

        # Listbox
        listbox_frame = tk.Frame(col_frame, bg=self.colors["bg_secondary"])
        listbox_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        listbox = tk.Listbox(
            listbox_frame,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            selectbackground=self.colors["bg_accent"],
            selectforeground=self.colors["text_primary"],
            font=("Segoe UI", 10),
            relief="flat",
            bd=0,
        )

        scrollbar = tk.Scrollbar(listbox_frame, orient="vertical")
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.configure(command=listbox.yview)

        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Configurar eventos
        if list_type == "categories":
            self.categories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_category_select)
        elif list_type == "subcategories":
            self.subcategories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_subcategory_select)
        elif list_type == "phrases":
            self.phrases_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_phrase_select)

    def create_preview_area(self):
        """Criar √°rea de preview da frase"""
        preview_frame = tk.Frame(
            self.root, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        preview_frame.pack(fill=tk.X, padx=10, pady=5)

        # T√≠tulo
        preview_title = tk.Label(
            preview_frame,
            text="üëÅÔ∏è Preview da Frase Selecionada",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=5,
        )
        preview_title.pack()

        # √Årea de texto
        text_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        text_frame.pack(fill=tk.X, padx=10, pady=5)

        self.preview_text = tk.Text(
            text_frame,
            height=6,
            wrap=tk.WORD,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Consolas", 10),
            relief="flat",
            bd=0,
            state="disabled",
        )

        preview_scrollbar = tk.Scrollbar(text_frame, orient="vertical")
        self.preview_text.configure(yscrollcommand=preview_scrollbar.set)
        preview_scrollbar.configure(command=self.preview_text.yview)

        self.preview_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        preview_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Bot√µes de a√ß√£o
        buttons_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        buttons_frame.pack(pady=10)

        # Bot√£o de digitar
        self.type_button = tk.Button(
            buttons_frame,
            text="‚å®Ô∏è Digitar Automaticamente (F5)",
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.auto_type_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.type_button.pack(side=tk.LEFT, padx=5)

        # Bot√£o de copiar
        self.copy_button = tk.Button(
            buttons_frame,
            text="üìã Copiar para Clipboard",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.copy_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.copy_button.pack(side=tk.LEFT, padx=5)

    def create_status_bar(self):
        """Criar barra de status"""
        self.status_bar = tk.Label(
            self.root,
            text="Pronto - Conecte-se ao Pi Zero",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 9),
            relief="sunken",
            bd=1,
            anchor="w",
            padx=10,
        )
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def setup_keyboard_shortcuts(self):
        """Configurar atalhos de teclado globais usando HotKey para combina√ß√µes."""
        if not PYNPUT_AVAILABLE:
            self.update_status(
                "Atalhos de teclado desativados. Instale 'pynput' para habilit√°-los."
            )
            return

        def on_type_activate():
            print("Atalho Ctrl+Alt+D ativado: Digitar frase.")
            self.auto_type_phrase()

        def on_copy_activate():
            print("Atalho Ctrl+Alt+C ativado: Copiar frase.")
            self.copy_phrase()

        def on_minimize_activate():
            print("Atalho Ctrl+Alt+M ativado: Minimizar/Restaurar.")
            self.toggle_minimize()

        # Definir os atalhos
        hotkeys = {
            '<ctrl>+<alt>+d': on_type_activate,
            '<ctrl>+<alt>+c': on_copy_activate,
            '<ctrl>+<alt>m': on_minimize_activate,
        }

        # Iniciar o listener em uma thread separada
        listener = keyboard.GlobalHotKeys(hotkeys)
        listener.start()

        self.update_status(
            "Pronto. Atalhos: Ctrl+Alt+D (digitar), Ctrl+Alt+C (copiar), Ctrl+Alt+M (minimizar)."
        )

    def setup_gui(self):
        """Criar interface do cliente."""
        # Paleta comum para fallback/legado
        self.colors = {
            "bg_primary": "#1a237e",  # Azul escuro principal
            "bg_secondary": "#283593",  # Azul m√©dio
            "bg_accent": "#3f51b5",  # Azul claro
            "text_primary": "#ffffff",  # Branco
            "text_secondary": "#e8eaf6",  # Branco levemente azulado
            "button_active": "#4caf50",  # Verde
            "button_hover": "#66bb6a",  # Verde claro
            "border": "#5c6bc0",  # Azul para bordas
        }

        pi_reachable = self.is_pi_reachable()

        if WEBVIEW_AVAILABLE and pi_reachable and not self.force_legacy_ui:
            self.ui_mode = "webview"
            self.webview_window = webview.create_window(
                "Automa√ß√£o M√©dica",
                self.pi_url,
                width=1000,
                height=700,
                resizable=True,
            )
            return

        # Necess√°rio criar janela Tk para fallback ou interface legada
        self.root = tk.Tk()
        self.root.title("Automa√ß√£o M√©dica")
        self.root.geometry("1000x700")
        self.root.configure(bg=self.colors["bg_primary"])
        self.root.attributes("-topmost", True)

        if not pi_reachable:
            self.ui_mode = "fallback"
            self.build_offline_screen()
            return

        # Quando pywebview n√£o est√° dispon√≠vel, mantemos a UI Tk existente
        if not WEBVIEW_AVAILABLE:
            print(
                "pywebview n√£o foi encontrado. Utilizando interface Tkinter tradicional."
            )

        self.ui_mode = "legacy"

        # Configurar estilo ttk apenas no modo legado
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Dark.TFrame", background=self.colors["bg_primary"])
        style.configure(
            "Dark.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10),
        )
        style.configure(
            "Title.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 16, "bold"),
        )
        style.configure(
            "Dark.TButton",
            background=self.colors["bg_accent"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10, "bold"),
        )

        self.create_header()
        
        self.create_navigation_area()
        self.create_preview_area()
        self.create_status_bar()

        self.root.focus_set()
        self.root.bind("<Escape>", lambda e: self.toggle_minimize())
        self.root.bind("<F11>", lambda e: self.toggle_fullscreen())

    def build_offline_screen(self):
        """Exibir tela simples informando aus√™ncia de conex√£o."""
        container = tk.Frame(self.root, bg=self.colors["bg_primary"])
        container.pack(expand=True, fill=tk.BOTH, padx=40, pady=40)

        title = tk.Label(
            container,
            text="N√£o foi poss√≠vel acessar o Raspberry Pi.",
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 18, "bold"),
            wraplength=600,
            justify="center",
        )
        title.pack(pady=(0, 20))

        instructions = (
            "Verifique se o Raspberry Pi est√° ligado e conectado √† rede. "
            "Conecte o computador ao mesmo Wi-Fi ou cabo e tente novamente."
        )
        self.fallback_status_var = tk.StringVar(value=instructions)
        status_label = tk.Label(
            container,
            textvariable=self.fallback_status_var,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 11),
            wraplength=600,
            justify="center",
        )
        status_label.pack(pady=(0, 20))

        button_frame = tk.Frame(container, bg=self.colors["bg_primary"])
        button_frame.pack()

        retry_button = tk.Button(
            button_frame,
            text="Tentar novamente",
            command=self.retry_connection,
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        retry_button.pack(side=tk.LEFT, padx=10)

        close_button = tk.Button(
            button_frame,
            text="Fechar",
            command=self.root.destroy,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        close_button.pack(side=tk.LEFT, padx=10)

        if not WEBVIEW_AVAILABLE:
            note = tk.Label(
                container,
                text=(
                    "Observa√ß√£o: instale o pacote 'pywebview' para carregar a interface "
                    "web moderna diretamente no aplicativo."
                ),
                bg=self.colors["bg_primary"],
                fg=self.colors["text_secondary"],
                font=("Segoe UI", 10),
                wraplength=600,
                justify="center",
            )
            note.pack(pady=(20, 0))

    def retry_connection(self):
        """Tentar reconectar ao Pi e abrir a webview se poss√≠vel."""
        if not self.is_pi_reachable():
            self.fallback_status_var.set(
                "Ainda n√£o foi poss√≠vel conectar. Confira os cabos/rede e tente novamente."
            )
            return

        if WEBVIEW_AVAILABLE:
            self.fallback_status_var.set(
                "Conex√£o restabelecida! Abrindo a interface web..."
            )
            self.root.after(200, self._open_webview_after_fallback)
        else:
            self.fallback_status_var.set(
                "Conectado ao Pi! Instale o pacote 'pywebview' e reabra o aplicativo "
                "para usar a interface moderna."
            )

    def _open_webview_after_fallback(self):
        """Encerrar a janela Tk e preparar a webview."""
        if not WEBVIEW_AVAILABLE:
            return
        self.pending_webview = True
        self.force_legacy_ui = False
        if self.root:
            self.root.destroy()
            self.root = None
        self.webview_window = webview.create_window(
            "Automa√ß√£o M√©dica",
            self.pi_url,
            width=1000,
            height=700,
            resizable=True,
        )

    def is_pi_reachable(self, timeout=3):
        """Verificar se a URL do Pi responde."""
        try:
            if REQUESTS_AVAILABLE:
                response = requests.get(self.pi_url, timeout=timeout)
                return response.status_code < 500
            with urllib_request.urlopen(self.pi_url, timeout=timeout) as response:
                return 200 <= getattr(response, "status", 200) < 500
            return False
        except Exception as e:
            print(f"Falha ao verificar a disponibilidade do Pi: {e}")
            traceback.print_exc()
            return False

    def create_header(self):
        """Criar cabe√ßalho"""
        header_frame = tk.Frame(self.root, bg=self.colors["bg_secondary"], height=80)
        header_frame.pack(fill=tk.X, padx=2, pady=2)
        header_frame.pack_propagate(False)

        # T√≠tulo
        title_label = tk.Label(
            header_frame,
            text="üè• Automa√ß√£o M√©dica",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 20, "bold"),
        )
        title_label.pack(expand=True)

        # Subt√≠tulo
        subtitle_label = tk.Label(
            header_frame,
            text="Neurologia",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 12),
        )
        subtitle_label.pack()

    

    def create_navigation_area(self):
        """Criar √°rea de navega√ß√£o com 3 colunas"""
        nav_frame = tk.Frame(self.root, bg=self.colors["bg_primary"])
        nav_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Configurar grid
        nav_frame.grid_columnconfigure(0, weight=1)
        nav_frame.grid_columnconfigure(1, weight=1)
        nav_frame.grid_columnconfigure(2, weight=1)
        nav_frame.grid_rowconfigure(0, weight=1)

        # Coluna 1: Categorias
        self.create_list_column(nav_frame, "üìã Categorias", 0, "categories")

        # Coluna 2: Subcategorias
        self.create_list_column(nav_frame, "üìë Subcategorias", 1, "subcategories")

        # Coluna 3: Frases
        self.create_list_column(nav_frame, "üí¨ Frases", 2, "phrases")

    def create_list_column(self, parent, title, column, list_type):
        """Criar uma coluna de lista"""
        # Frame da coluna
        col_frame = tk.Frame(
            parent, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        col_frame.grid(row=0, column=column, sticky="nsew", padx=2, pady=2)

        # T√≠tulo
        title_label = tk.Label(
            col_frame,
            text=title,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=10,
        )
        title_label.pack(fill=tk.X)

        # Listbox
        listbox_frame = tk.Frame(col_frame, bg=self.colors["bg_secondary"])
        listbox_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        listbox = tk.Listbox(
            listbox_frame,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            selectbackground=self.colors["bg_accent"],
            selectforeground=self.colors["text_primary"],
            font=("Segoe UI", 10),
            relief="flat",
            bd=0,
        )

        scrollbar = tk.Scrollbar(listbox_frame, orient="vertical")
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.configure(command=listbox.yview)

        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Configurar eventos
        if list_type == "categories":
            self.categories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_category_select)
        elif list_type == "subcategories":
            self.subcategories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_subcategory_select)
        elif list_type == "phrases":
            self.phrases_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_phrase_select)

    def create_preview_area(self):
        """Criar √°rea de preview da frase"""
        preview_frame = tk.Frame(
            self.root, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        preview_frame.pack(fill=tk.X, padx=10, pady=5)

        # T√≠tulo
        preview_title = tk.Label(
            preview_frame,
            text="üëÅÔ∏è Preview da Frase Selecionada",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=5,
        )
        preview_title.pack()

        # √Årea de texto
        text_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        text_frame.pack(fill=tk.X, padx=10, pady=5)

        self.preview_text = tk.Text(
            text_frame,
            height=6,
            wrap=tk.WORD,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Consolas", 10),
            relief="flat",
            bd=0,
            state="disabled",
        )

        preview_scrollbar = tk.Scrollbar(text_frame, orient="vertical")
        self.preview_text.configure(yscrollcommand=preview_scrollbar.set)
        preview_scrollbar.configure(command=self.preview_text.yview)

        self.preview_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        preview_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Bot√µes de a√ß√£o
        buttons_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        buttons_frame.pack(pady=10)

        # Bot√£o de digitar
        self.type_button = tk.Button(
            buttons_frame,
            text="‚å®Ô∏è Digitar Automaticamente (F5)",
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.auto_type_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.type_button.pack(side=tk.LEFT, padx=5)

        # Bot√£o de copiar
        self.copy_button = tk.Button(
            buttons_frame,
            text="üìã Copiar para Clipboard",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.copy_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.copy_button.pack(side=tk.LEFT, padx=5)

    def create_status_bar(self):
        """Criar barra de status"""
        self.status_bar = tk.Label(
            self.root,
            text="Pronto - Conecte-se ao Pi Zero",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 9),
            relief="sunken",
            bd=1,
            anchor="w",
            padx=10,
        )
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def setup_keyboard_shortcuts(self):
        """Configurar atalhos de teclado globais usando HotKey para combina√ß√µes."""
        if not PYNPUT_AVAILABLE:
            self.update_status(
                "Atalhos de teclado desativados. Instale 'pynput' para habilit√°-los."
            )
            return

        def on_type_activate():
            print("Atalho Ctrl+Alt+D ativado: Digitar frase.")
            self.auto_type_phrase()

        def on_copy_activate():
            print("Atalho Ctrl+Alt+C ativado: Copiar frase.")
            self.copy_phrase()

        def on_minimize_activate():
            print("Atalho Ctrl+Alt+M ativado: Minimizar/Restaurar.")
            self.toggle_minimize()

        # Definir os atalhos
        hotkeys = {
            '<ctrl>+<alt>+d': on_type_activate,
            '<ctrl>+<alt>+c': on_copy_activate,
            '<ctrl>+<alt>m': on_minimize_activate,
        }

        # Iniciar o listener em uma thread separada
        listener = keyboard.GlobalHotKeys(hotkeys)
        listener.start()

        self.update_status(
            "Pronto. Atalhos: Ctrl+Alt+D (digitar), Ctrl+Alt+C (copiar), Ctrl+Alt+M (minimizar)."
        )

    def setup_gui(self):
        """Criar interface do cliente."""
        # Paleta comum para fallback/legado
        self.colors = {
            "bg_primary": "#1a237e",  # Azul escuro principal
            "bg_secondary": "#283593",  # Azul m√©dio
            "bg_accent": "#3f51b5",  # Azul claro
            "text_primary": "#ffffff",  # Branco
            "text_secondary": "#e8eaf6",  # Branco levemente azulado
            "button_active": "#4caf50",  # Verde
            "button_hover": "#66bb6a",  # Verde claro
            "border": "#5c6bc0",  # Azul para bordas
        }

        pi_reachable = self.is_pi_reachable()

        if WEBVIEW_AVAILABLE and pi_reachable and not self.force_legacy_ui:
            self.ui_mode = "webview"
            self.webview_window = webview.create_window(
                "Automa√ß√£o M√©dica",
                self.pi_url,
                width=1000,
                height=700,
                resizable=True,
            )
            return

        # Necess√°rio criar janela Tk para fallback ou interface legada
        self.root = tk.Tk()
        self.root.title("Automa√ß√£o M√©dica")
        self.root.geometry("1000x700")
        self.root.configure(bg=self.colors["bg_primary"])
        self.root.attributes("-topmost", True)

        if not pi_reachable:
            self.ui_mode = "fallback"
            self.build_offline_screen()
            return

        # Quando pywebview n√£o est√° dispon√≠vel, mantemos a UI Tk existente
        if not WEBVIEW_AVAILABLE:
            print(
                "pywebview n√£o foi encontrado. Utilizando interface Tkinter tradicional."
            )

        self.ui_mode = "legacy"

        # Configurar estilo ttk apenas no modo legado
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Dark.TFrame", background=self.colors["bg_primary"])
        style.configure(
            "Dark.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10),
        )
        style.configure(
            "Title.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 16, "bold"),
        )
        style.configure(
            "Dark.TButton",
            background=self.colors["bg_accent"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10, "bold"),
        )

        self.create_header()
        
        self.create_navigation_area()
        self.create_preview_area()
        self.create_status_bar()

        self.root.focus_set()
        self.root.bind("<Escape>", lambda e: self.toggle_minimize())
        self.root.bind("<F11>", lambda e: self.toggle_fullscreen())

    def build_offline_screen(self):
        """Exibir tela simples informando aus√™ncia de conex√£o."""
        container = tk.Frame(self.root, bg=self.colors["bg_primary"])
        container.pack(expand=True, fill=tk.BOTH, padx=40, pady=40)

        title = tk.Label(
            container,
            text="N√£o foi poss√≠vel acessar o Raspberry Pi.",
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 18, "bold"),
            wraplength=600,
            justify="center",
        )
        title.pack(pady=(0, 20))

        instructions = (
            "Verifique se o Raspberry Pi est√° ligado e conectado √† rede. "
            "Conecte o computador ao mesmo Wi-Fi ou cabo e tente novamente."
        )
        self.fallback_status_var = tk.StringVar(value=instructions)
        status_label = tk.Label(
            container,
            textvariable=self.fallback_status_var,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 11),
            wraplength=600,
            justify="center",
        )
        status_label.pack(pady=(0, 20))

        button_frame = tk.Frame(container, bg=self.colors["bg_primary"])
        button_frame.pack()

        retry_button = tk.Button(
            button_frame,
            text="Tentar novamente",
            command=self.retry_connection,
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        retry_button.pack(side=tk.LEFT, padx=10)

        close_button = tk.Button(
            button_frame,
            text="Fechar",
            command=self.root.destroy,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        close_button.pack(side=tk.LEFT, padx=10)

        if not WEBVIEW_AVAILABLE:
            note = tk.Label(
                container,
                text=(
                    "Observa√ß√£o: instale o pacote 'pywebview' para carregar a interface "
                    "web moderna diretamente no aplicativo."
                ),
                bg=self.colors["bg_primary"],
                fg=self.colors["text_secondary"],
                font=("Segoe UI", 10),
                wraplength=600,
                justify="center",
            )
            note.pack(pady=(20, 0))

    def retry_connection(self):
        """Tentar reconectar ao Pi e abrir a webview se poss√≠vel."""
        if not self.is_pi_reachable():
            self.fallback_status_var.set(
                "Ainda n√£o foi poss√≠vel conectar. Confira os cabos/rede e tente novamente."
            )
            return

        if WEBVIEW_AVAILABLE:
            self.fallback_status_var.set(
                "Conex√£o restabelecida! Abrindo a interface web..."
            )
            self.root.after(200, self._open_webview_after_fallback)
        else:
            self.fallback_status_var.set(
                "Conectado ao Pi! Instale o pacote 'pywebview' e reabra o aplicativo "
                "para usar a interface moderna."
            )

    def _open_webview_after_fallback(self):
        """Encerrar a janela Tk e preparar a webview."""
        if not WEBVIEW_AVAILABLE:
            return
        self.pending_webview = True
        self.force_legacy_ui = False
        if self.root:
            self.root.destroy()
            self.root = None
        self.webview_window = webview.create_window(
            "Automa√ß√£o M√©dica",
            self.pi_url,
            width=1000,
            height=700,
            resizable=True,
        )

    def is_pi_reachable(self, timeout=3):
        """Verificar se a URL do Pi responde."""
        try:
            if REQUESTS_AVAILABLE:
                response = requests.get(self.pi_url, timeout=timeout)
                return response.status_code < 500
            with urllib_request.urlopen(self.pi_url, timeout=timeout) as response:
                return 200 <= getattr(response, "status", 200) < 500
            return False
        except Exception as e:
            print(f"Falha ao verificar a disponibilidade do Pi: {e}")
            traceback.print_exc()
            return False

    def create_header(self):
        """Criar cabe√ßalho"""
        header_frame = tk.Frame(self.root, bg=self.colors["bg_secondary"], height=80)
        header_frame.pack(fill=tk.X, padx=2, pady=2)
        header_frame.pack_propagate(False)

        # T√≠tulo
        title_label = tk.Label(
            header_frame,
            text="üè• Automa√ß√£o M√©dica",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 20, "bold"),
        )
        title_label.pack(expand=True)

        # Subt√≠tulo
        subtitle_label = tk.Label(
            header_frame,
            text="Neurologia",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 12),
        )
        subtitle_label.pack()

    

    def create_navigation_area(self):
        """Criar √°rea de navega√ß√£o com 3 colunas"""
        nav_frame = tk.Frame(self.root, bg=self.colors["bg_primary"])
        nav_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Configurar grid
        nav_frame.grid_columnconfigure(0, weight=1)
        nav_frame.grid_columnconfigure(1, weight=1)
        nav_frame.grid_columnconfigure(2, weight=1)
        nav_frame.grid_rowconfigure(0, weight=1)

        # Coluna 1: Categorias
        self.create_list_column(nav_frame, "üìã Categorias", 0, "categories")

        # Coluna 2: Subcategorias
        self.create_list_column(nav_frame, "üìë Subcategorias", 1, "subcategories")

        # Coluna 3: Frases
        self.create_list_column(nav_frame, "üí¨ Frases", 2, "phrases")

    def create_list_column(self, parent, title, column, list_type):
        """Criar uma coluna de lista"""
        # Frame da coluna
        col_frame = tk.Frame(
            parent, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        col_frame.grid(row=0, column=column, sticky="nsew", padx=2, pady=2)

        # T√≠tulo
        title_label = tk.Label(
            col_frame,
            text=title,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=10,
        )
        title_label.pack(fill=tk.X)

        # Listbox
        listbox_frame = tk.Frame(col_frame, bg=self.colors["bg_secondary"])
        listbox_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        listbox = tk.Listbox(
            listbox_frame,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            selectbackground=self.colors["bg_accent"],
            selectforeground=self.colors["text_primary"],
            font=("Segoe UI", 10),
            relief="flat",
            bd=0,
        )

        scrollbar = tk.Scrollbar(listbox_frame, orient="vertical")
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.configure(command=listbox.yview)

        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Configurar eventos
        if list_type == "categories":
            self.categories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_category_select)
        elif list_type == "subcategories":
            self.subcategories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_subcategory_select)
        elif list_type == "phrases":
            self.phrases_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_phrase_select)

    def create_preview_area(self):
        """Criar √°rea de preview da frase"""
        preview_frame = tk.Frame(
            self.root, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        preview_frame.pack(fill=tk.X, padx=10, pady=5)

        # T√≠tulo
        preview_title = tk.Label(
            preview_frame,
            text="üëÅÔ∏è Preview da Frase Selecionada",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=5,
        )
        preview_title.pack()

        # √Årea de texto
        text_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        text_frame.pack(fill=tk.X, padx=10, pady=5)

        self.preview_text = tk.Text(
            text_frame,
            height=6,
            wrap=tk.WORD,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Consolas", 10),
            relief="flat",
            bd=0,
            state="disabled",
        )

        preview_scrollbar = tk.Scrollbar(text_frame, orient="vertical")
        self.preview_text.configure(yscrollcommand=preview_scrollbar.set)
        preview_scrollbar.configure(command=self.preview_text.yview)

        self.preview_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        preview_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Bot√µes de a√ß√£o
        buttons_frame = tk.Frame(preview_frame, bg=self.colors["bg_secondary"])
        buttons_frame.pack(pady=10)

        # Bot√£o de digitar
        self.type_button = tk.Button(
            buttons_frame,
            text="‚å®Ô∏è Digitar Automaticamente (F5)",
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.auto_type_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.type_button.pack(side=tk.LEFT, padx=5)

        # Bot√£o de copiar
        self.copy_button = tk.Button(
            buttons_frame,
            text="üìã Copiar para Clipboard",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            command=self.copy_phrase,
            relief="raised",
            bd=2,
            padx=20,
            pady=8,
        )
        self.copy_button.pack(side=tk.LEFT, padx=5)

    def create_status_bar(self):
        """Criar barra de status"""
        self.status_bar = tk.Label(
            self.root,
            text="Pronto - Conecte-se ao Pi Zero",
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 9),
            relief="sunken",
            bd=1,
            anchor="w",
            padx=10,
        )
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def setup_keyboard_shortcuts(self):
        """Configurar atalhos de teclado globais usando HotKey para combina√ß√µes."""
        if not PYNPUT_AVAILABLE:
            self.update_status(
                "Atalhos de teclado desativados. Instale 'pynput' para habilit√°-los."
            )
            return

        def on_type_activate():
            print("Atalho Ctrl+Alt+D ativado: Digitar frase.")
            self.auto_type_phrase()

        def on_copy_activate():
            print("Atalho Ctrl+Alt+C ativado: Copiar frase.")
            self.copy_phrase()

        def on_minimize_activate():
            print("Atalho Ctrl+Alt+M ativado: Minimizar/Restaurar.")
            self.toggle_minimize()

        # Definir os atalhos
        hotkeys = {
            '<ctrl>+<alt>+d': on_type_activate,
            '<ctrl>+<alt>+c': on_copy_activate,
            '<ctrl>+<alt>m': on_minimize_activate,
        }

        # Iniciar o listener em uma thread separada
        listener = keyboard.GlobalHotKeys(hotkeys)
        listener.start()

        self.update_status(
            "Pronto. Atalhos: Ctrl+Alt+D (digitar), Ctrl+Alt+C (copiar), Ctrl+Alt+M (minimizar)."
        )

    def setup_gui(self):
        """Criar interface do cliente."""
        # Paleta comum para fallback/legado
        self.colors = {
            "bg_primary": "#1a237e",  # Azul escuro principal
            "bg_secondary": "#283593",  # Azul m√©dio
            "bg_accent": "#3f51b5",  # Azul claro
            "text_primary": "#ffffff",  # Branco
            "text_secondary": "#e8eaf6",  # Branco levemente azulado
            "button_active": "#4caf50",  # Verde
            "button_hover": "#66bb6a",  # Verde claro
            "border": "#5c6bc0",  # Azul para bordas
        }

        pi_reachable = self.is_pi_reachable()

        if WEBVIEW_AVAILABLE and pi_reachable and not self.force_legacy_ui:
            self.ui_mode = "webview"
            self.webview_window = webview.create_window(
                "Automa√ß√£o M√©dica",
                self.pi_url,
                width=1000,
                height=700,
                resizable=True,
            )
            return

        # Necess√°rio criar janela Tk para fallback ou interface legada
        self.root = tk.Tk()
        self.root.title("Automa√ß√£o M√©dica")
        self.root.geometry("1000x700")
        self.root.configure(bg=self.colors["bg_primary"])
        self.root.attributes("-topmost", True)

        if not pi_reachable:
            self.ui_mode = "fallback"
            self.build_offline_screen()
            return

        # Quando pywebview n√£o est√° dispon√≠vel, mantemos a UI Tk existente
        if not WEBVIEW_AVAILABLE:
            print(
                "pywebview n√£o foi encontrado. Utilizando interface Tkinter tradicional."
            )

        self.ui_mode = "legacy"

        # Configurar estilo ttk apenas no modo legado
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Dark.TFrame", background=self.colors["bg_primary"])
        style.configure(
            "Dark.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10),
        )
        style.configure(
            "Title.TLabel",
            background=self.colors["bg_primary"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 16, "bold"),
        )
        style.configure(
            "Dark.TButton",
            background=self.colors["bg_accent"],
            foreground=self.colors["text_primary"],
            font=("Segoe UI", 10, "bold"),
        )

        self.create_header()
        
        self.create_navigation_area()
        self.create_preview_area()
        self.create_status_bar()

        self.root.focus_set()
        self.root.bind("<Escape>", lambda e: self.toggle_minimize())
        self.root.bind("<F11>", lambda e: self.toggle_fullscreen())

    def build_offline_screen(self):
        """Exibir tela simples informando aus√™ncia de conex√£o."""
        container = tk.Frame(self.root, bg=self.colors["bg_primary"])
        container.pack(expand=True, fill=tk.BOTH, padx=40, pady=40)

        title = tk.Label(
            container,
            text="N√£o foi poss√≠vel acessar o Raspberry Pi.",
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 18, "bold"),
            wraplength=600,
            justify="center",
        )
        title.pack(pady=(0, 20))

        instructions = (
            "Verifique se o Raspberry Pi est√° ligado e conectado √† rede. "
            "Conecte o computador ao mesmo Wi-Fi ou cabo e tente novamente."
        )
        self.fallback_status_var = tk.StringVar(value=instructions)
        status_label = tk.Label(
            container,
            textvariable=self.fallback_status_var,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 11),
            wraplength=600,
            justify="center",
        )
        status_label.pack(pady=(0, 20))

        button_frame = tk.Frame(container, bg=self.colors["bg_primary"])
        button_frame.pack()

        retry_button = tk.Button(
            button_frame,
            text="Tentar novamente",
            command=self.retry_connection,
            bg=self.colors["button_active"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        retry_button.pack(side=tk.LEFT, padx=10)

        close_button = tk.Button(
            button_frame,
            text="Fechar",
            command=self.root.destroy,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 11, "bold"),
            padx=16,
            pady=8,
        )
        close_button.pack(side=tk.LEFT, padx=10)

        if not WEBVIEW_AVAILABLE:
            note = tk.Label(
                container,
                text=(
                    "Observa√ß√£o: instale o pacote 'pywebview' para carregar a interface "
                    "web moderna diretamente no aplicativo."
                ),
                bg=self.colors["bg_primary"],
                fg=self.colors["text_secondary"],
                font=("Segoe UI", 10),
                wraplength=600,
                justify="center",
            )
            note.pack(pady=(20, 0))

    def retry_connection(self):
        """Tentar reconectar ao Pi e abrir a webview se poss√≠vel."""
        if not self.is_pi_reachable():
            self.fallback_status_var.set(
                "Ainda n√£o foi poss√≠vel conectar. Confira os cabos/rede e tente novamente."
            )
            return

        if WEBVIEW_AVAILABLE:
            self.fallback_status_var.set(
                "Conex√£o restabelecida! Abrindo a interface web..."
            )
            self.root.after(200, self._open_webview_after_fallback)
        else:
            self.fallback_status_var.set(
                "Conectado ao Pi! Instale o pacote 'pywebview' e reabra o aplicativo "
                "para usar a interface moderna."
            )

    def _open_webview_after_fallback(self):
        """Encerrar a janela Tk e preparar a webview."""
        if not WEBVIEW_AVAILABLE:
            return
        self.pending_webview = True
        self.force_legacy_ui = False
        if self.root:
            self.root.destroy()
            self.root = None
        self.webview_window = webview.create_window(
            "Automa√ß√£o M√©dica",
            self.pi_url,
            width=1000,
            height=700,
            resizable=True,
        )

    def is_pi_reachable(self, timeout=3):
        """Verificar se a URL do Pi responde."""
        try:
            if REQUESTS_AVAILABLE:
                response = requests.get(self.pi_url, timeout=timeout)
                return response.status_code < 500
            with urllib_request.urlopen(self.pi_url, timeout=timeout) as response:
                return 200 <= getattr(response, "status", 200) < 500
            return False
        except Exception as e:
            print(f"Falha ao verificar a disponibilidade do Pi: {e}")
            traceback.print_exc()
            return False

    def create_header(self):
        """Criar cabe√ßalho"""
        header_frame = tk.Frame(self.root, bg=self.colors["bg_secondary"], height=80)
        header_frame.pack(fill=tk.X, padx=2, pady=2)
        header_frame.pack_propagate(False)

        # T√≠tulo
        title_label = tk.Label(
            header_frame,
            text="üè• Automa√ß√£o M√©dica",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 20, "bold"),
        )
        title_label.pack(expand=True)

        # Subt√≠tulo
        subtitle_label = tk.Label(
            header_frame,
            text="Neurologia",
            bg=self.colors["bg_secondary"],
            fg=self.colors["text_secondary"],
            font=("Segoe UI", 12),
        )
        subtitle_label.pack()

    

    def create_navigation_area(self):
        """Criar √°rea de navega√ß√£o com 3 colunas"""
        nav_frame = tk.Frame(self.root, bg=self.colors["bg_primary"])
        nav_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Configurar grid
        nav_frame.grid_columnconfigure(0, weight=1)
        nav_frame.grid_columnconfigure(1, weight=1)
        nav_frame.grid_columnconfigure(2, weight=1)
        nav_frame.grid_rowconfigure(0, weight=1)

        # Coluna 1: Categorias
        self.create_list_column(nav_frame, "üìã Categorias", 0, "categories")

        # Coluna 2: Subcategorias
        self.create_list_column(nav_frame, "üìë Subcategorias", 1, "subcategories")

        # Coluna 3: Frases
        self.create_list_column(nav_frame, "üí¨ Frases", 2, "phrases")

    def create_list_column(self, parent, title, column, list_type):
        """Criar uma coluna de lista"""
        # Frame da coluna
        col_frame = tk.Frame(
            parent, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        col_frame.grid(row=0, column=column, sticky="nsew", padx=2, pady=2)

        # T√≠tulo
        title_label = tk.Label(
            col_frame,
            text=title,
            bg=self.colors["bg_accent"],
            fg=self.colors["text_primary"],
            font=("Segoe UI", 12, "bold"),
            pady=10,
        )
        title_label.pack(fill=tk.X)

        # Listbox
        listbox_frame = tk.Frame(col_frame, bg=self.colors["bg_secondary"])
        listbox_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        listbox = tk.Listbox(
            listbox_frame,
            bg=self.colors["bg_primary"],
            fg=self.colors["text_primary"],
            selectbackground=self.colors["bg_accent"],
            selectforeground=self.colors["text_primary"],
            font=("Segoe UI", 10),
            relief="flat",
            bd=0,
        )

        scrollbar = tk.Scrollbar(listbox_frame, orient="vertical")
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.configure(command=listbox.yview)

        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Configurar eventos
        if list_type == "categories":
            self.categories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_category_select)
        elif list_type == "subcategories":
            self.subcategories_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_subcategory_select)
        elif list_type == "phrases":
            self.phrases_listbox = listbox
            listbox.bind("<<ListboxSelect>>", self.on_phrase_select)

    def create_preview_area(self):
        """Criar √°rea de preview da frase"""
        preview_frame = tk.Frame(
            self.root, bg=self.colors["bg_secondary"], relief="raised", bd=2
        )
        preview_frame.pack(fill=tk.X, padx=10, pady=5)

        # T√≠tulo
        preview_title = tk.Label(
            preview_frame,
            text="üëÅÔ∏è Preview da Frase Selecionada",
            bg